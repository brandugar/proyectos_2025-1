# -*- coding: utf-8 -*-
"""cholesky_paralelo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zF3qt0h98BIS9YgGokG_v9NRX04f7AU6

**cholesky con paralelismo**
"""

import numpy as np
import threading
import time

def cargar_matriz_csv(ruta_csv):
    A = np.loadtxt(ruta_csv, delimiter=',')
    N = A.shape[0]
    print("Matriz A cargada desde CSV:")
    print(A)
    return A, N

def inicializar_matriz_inversa(N):
    matriz_inv = np.zeros((N, N))
    print("\nMatriz inversa inicializada en ceros:")
    print(matriz_inv)
    return matriz_inv

def descomposicion_cholesky(A):
    N = A.shape[0]
    #Se inicializa la matriz L
    L = np.zeros_like(A)
    #Recorre filas i y columnas j
    for i in range(N):
        for j in range(i+1):
            suma = 0.0
            #Elementos de la diagonal con la sumatoria de su formula para el calculo de L
            if j == i:
                for k in range(j):
                    suma += L[j,k] ** 2
                #Utilizamos val para avanzar en la formula y el calculo de si es positiva la matriz si no arrojamos error
                val = A[j,j] - suma
                if val <= 0:
                    raise ValueError(f"La matriz no es definida positiva en la posición ({j},{j})")
                #Se saca la raiz para completar la formula de la diagonal
                L[j,j] = np.sqrt(val)
            else:
                #Formula para los elementos fuera de la diagonal
                for k in range(j):
                    suma += L[i,k] * L[j,k]
                L[i,j] = (A[i,j] - suma) / L[j,j]
    print("\nMatriz L (Cholesky) calculada:")
    print(L)
    return L

def forward_substitution(L, e):
    N = L.shape[0]
    #Inici el vector para guardar los resultados
    y = np.zeros(N)
    #Se aplica la formula
    for j in range(N):
        suma = 0.0
        for k in range(j):
            suma += L[j, k] * y[k]
        y[j] = (e[j] - suma) / L[j, j]
    return y

def backward_substitution(L, y):
    N = L.shape[0]
    #Inicializamos el vector para guardar los resultados
    x = np.zeros(N)
    #Aplicamos la formula
    for j in reversed(range(N)):
        suma = 0.0
        for k in range(j+1, N):
            suma += L[k, j] * x[k]
        x[j] = (y[j] - suma) / L[j, j]
    return x

"""La funcion Calcular columna inversa
Calcula la columna i-ésima de la matrz invers usando cholesky y la guarda en la matriz inversa completa
"""

def calcular_columna_inversa(i, L, matriz_inv):
    """Calcula la columna i-ésima de la matriz inversa y la guarda en matriz_inv."""
    N = L.shape[0]
    e = np.zeros(N)
    e[i] = 1
    y = forward_substitution(L, e)
    x = backward_substitution(L, y)
    matriz_inv[:, i] = x

"""La funcion calcular inversa threading se encarga de calcular la inversa usando múltiples hilos para acelerar el proceso. Cada hilo usa la funcion anterior por cada hilo"""

def calcular_inversa_threading(L):
    N = L.shape[0]
    matriz_inv = np.zeros((N, N))
    threads = []

    # Crear un hilo por columna
    for i in range(N):
        t = threading.Thread(target=calcular_columna_inversa, args=(i, L, matriz_inv))
        threads.append(t)
        t.start()

    # Esperar que todos los hilos terminen
    for t in threads:
        t.join()

    print("\nMatriz inversa calculada con Cholesky (threading):")
    print(matriz_inv)
    return matriz_inv

def main():
    # Cambia la ruta si tu CSV está en otra ubicación
    ruta_csv = 'matriz_500x500_dpi.csv'

    # 1. Cargar matriz
    A, N = cargar_matriz_csv(ruta_csv)

    # 3. Calcular descomposición de Cholesky
    L = descomposicion_cholesky(A)

    # 4. Calcular inversa
    matriz_inv = calcular_inversa_threading(L)

if __name__ == "__main__":
    inicio = time.time()    # ⏱️ Marca de tiempo inicial

    main()

    fin = time.time()       # ⏱️ Marca de tiempo final
    print(f"\nTiempo de ejecución total: {fin - inicio:.4f} segundos")